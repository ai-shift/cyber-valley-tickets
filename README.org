#+title: Cyber Valley Tickets
#+author: aishift
#+LATEX_HEADER: \usepackage[margin=1.3in]{geometry}

* Table of contents                                          :toc_3:noexport:
- [[#problem][Problem]]
- [[#solution][Solution]]
  - [[#roles][Roles]]
    - [[#customer][Customer]]
    - [[#staff][Staff]]
    - [[#creator][Creator]]
    - [[#master][Master]]
  - [[#use-cases][Use cases]]
    - [[#create-event-place][Create event place]]
    - [[#update-event-place][Update event place]]
    - [[#save-socials][Save socials]]
    - [[#approve-event-request][Approve event request]]
    - [[#decline-event-request][Decline event request]]
    - [[#edit-event][Edit event]]
    - [[#list-events][List events]]
    - [[#buy-ticket][Buy ticket]]
    - [[#add--remove-staff][Add / remove staff]]
    - [[#show-ticket][Show ticket]]
    - [[#verify-bought-ticket][Verify bought ticket]]
    - [[#close-event][Close event]]
  - [[#tech-stack][Tech stack]]
  - [[#excluded-features-from-the-first-stage][Excluded features from the first stage]]
  - [[#proxy-contract-vs-multiple-versions][Proxy contract vs multiple versions]]
  - [[#component-design][Component design]]
    - [[#general-overview][General overview]]
    - [[#smart-contract][Smart contract]]
    - [[#backend][Backend]]
- [[#questions][Questions]]
  - [[#both-desktop-and-mobile-are-required][Both desktop and mobile are required?]]
  - [[#is-it-required-to-verify-tickets-without-internet-connection][Is it required to verify tickets without internet connection?]]
  - [[#will-be-there-multiple-masters-or-the-only-one-in-foreseeable-future][Will be there multiple masters or the only one in foreseeable future?]]
  - [[#event-request-price-fixed-in-eth-depends-on-ethusd-rate-or-could-be-changed-by-the-master][Event request price fixed in ETH, depends on ETH/USD rate or could be changed by the master?]]
  - [[#is-a-ticket-transfer-allowed-eg-customer-a-bought-a-ticket-but-sent-it-to-the-customer-b][Is a ticket transfer allowed e.g. customer A bought a ticket, but sent it to the customer B?]]
  - [[#will-tickets-have-some-metainfo-about-the-owner-name-number-etc][Will tickets have some metainfo about the owner (name, number etc)]]
  - [[#is-it-applicable-to-show-available-seats-count-for-all-so-the-creator-and-master-can-see-it-as-well-without-additional-screen][Is it applicable to show available seats count for all (so the creator and master can see it as well without additional screen)?]]
  - [[#ui-design-references][UI design references]]

* Problem

Cyber Valley wants to host events and needs a convenient way to accept events offers from creators, sell tickets in crypto, verify bought tickets from customer's devices and distribution of acquired means across creator, master and dev team

* Solution

Create Web3 mobile first web app based on Ethereum network which covers main needs

** Roles

*** Customer

Public role which has the following authorities:

- List events
- Buy ticket to event

*** Staff

Assigned by the master role. Has all customer's authorities and:

- Verify tickets for any event

*** Creator

A.k.a shaman has all customer's authorities and:

- Send event request
- Edit own event requests
- See pending own event requests

*** Master

Has all customer's, staff's and creator's authorities and:

- Create event place
- Approve event requests
- Edit event requests
- Cancel event
- Close events

** Use cases

*** Create event place

*Accessible only by master*

Adds a new event place

*Emits* ~NewEventPlaceAvailable~

#+begin_src plantuml :file ./img/event-place.png
class EventPlace {
  minTickets: uint16
  maxTickets: uint16
  minPrice: uint16
  minDays: uint8
}
#+end_src

#+RESULTS:
[[file:./img/event-place.png]]

#+begin_src plantuml :file ./img/create-event-place.png
title Create event place

actor Master
participant TicketsApp
participant SmartContract

Master -> TicketsApp: New event place data
TicketsApp -> SmartContract: createEventPlace(maxTickets, minTickets, minPrice, minDays)
activate SmartContract
SmartContract -> SmartContract: _validateEventPlace(place)
SmartContract -->> TicketsApp: Emits NewEventPlaceAvailable
deactivate SmartContract
#+end_src

#+RESULTS:
[[file:./img/create-event-place.png]]

*** Update event place

*Accessible only by master*

Updates existing event place by it's id

@@warning:Event place can't be changed if there is another event@@

*Emits* ~EventPlaceUpdated~

#+begin_src plantuml :file ./img/update-event-place.png
title Update event place

actor Master
participant TicketsApp
participant SmartContract

Master -> TicketsApp: Updated event place data
TicketsApp -> SmartContract: updateEventPlace(eventPlaceId, maxTickets, minTickets, minPrice, minDays)
activate SmartContract
SmartContract -> SmartContract: _validateEventPlace(place)
SmartContract -->> TicketsApp: Emits EventPlaceUpdated
deactivate SmartContract
#+end_src

#+RESULTS:
[[file:./img/update-event-place.png]]

*** Save socials

Supported socials:

- Telegram
- Discord
- Whats App
- Instagram

**** V1

Used socials stored in the browser cache, so customer should input his social on each new device

#+begin_src plantuml :file ./img/v1-save-socials.png
title Save socials

actor Customer
participant TicketsApp
actor BrowserLocalStorage

Customer -> TicketsApp: Provide one of the socials
TicketsApp -> BrowserLocalStorage: Save socials for the future use
#+end_src

#+RESULTS:
[[file:./img/v1-save-socials.png]]

**** V2

Used socials stored in the centralized database which allows to sync state of the all devices

#+begin_src plantuml :file ./img/v2-save-socials.png
title Save socials

actor Customer
participant TicketsApp
participant Backend
participant Database
actor BrowserLocalStorage

Customer -> TicketsApp: Provide one of the socials
TicketsApp -> BrowserLocalStorage: Save socials for the future use
TicketsApp -> Backend: Send used socials
Backend -> Database: Persis used socials
#+end_src

#+RESULTS:
[[file:./img/v2-save-socials.png]]

*** COMMENT Submit event request

#+begin_src plantuml :file ./img/event-request.png
class EventRequest {
  eventPlaceId: uint256
  ticketPrice: uint16
  cancelDate: uint256
  startDate: uint256
  daysAmount: uint16
}
#+end_src

#+RESULTS:
[[file:./img/event-request.png]]

#+begin_src plantuml :file ./img/submit-event-request.png
title Submit event request

actor Creator
participant TicketsApp
participant EventManager
participant Backend
actor ERC20Contract
actor Master

Creator -> TicketsApp: Fill event request form
TicketsApp -> Backend: Store metadata
TicketsApp -> EventManager: Submit event request
activate EventManager
EventManager -> ERC20Contract: Transfer request fee
EventManager -->> Backend: Emits NewEventRequest
deactivate EventManager
TicketsApp -> Creator: Event successfully requested
TicketsApp -> Master: New event request
#+end_src

#+RESULTS:
[[file:./img/submit-event-request.png]]

*** Approve event request

#+begin_src plantuml :file ./img/approve-event-request.png
title Approve event request

actor Master
participant TicketsApp
participant EventManager
participant Backend

Master -> TicketsApp: Approve event
TicketsApp -> EventManager: Approve event
activate EventManager
EventManager -->> Backend: Emits EventStatusChanged
deactivate EventManager
#+end_src

#+RESULTS:
[[file:./img/approve-event-request.png]]

*** Decline event request

#+begin_src plantuml :file ./img/decline-event-request.png
title Decline event request

actor Master
participant TicketsApp
participant EventManager
participant Backend
actor ERC20Contract

Master -> TicketsApp: Decline event
TicketsApp -> EventManager: Decline event
activate EventManager
EventManager -> ERC20Contract: Refund request fee
EventManager -->> Backend: Emits EventStatusChanged
deactivate EventManager
#+end_src

#+RESULTS:
[[file:./img/decline-event-request.png]]

*** Edit event

#+begin_src plantuml :file ./img/edit-event-request.png
title Edit event request

actor Creator
participant TicketsApp
participant EventManager
participant Backend

Creator -> TicketsApp: Edit event request
activate EventManager
alt Event request is pending
  TicketsApp -> EventManager: Update event data
  EventManager -->> TicketsApp: Emits EventUpdated
  TicketsApp -> Creator: Event request updated
else Event approved
  TicketsApp -> EventManager: Add event edit
  EventManager -->> TicketsApp: Emits EventEditRequested
  TicketsApp -> Master: Requested edition of approved event
end
deactivate EventManager
#+end_src

#+RESULTS:
[[file:./img/edit-event-request.png]]

*** List events

#+begin_src plantuml :file ./img/list-events.png
title List events

actor Customer
participant TicketsApp
participant Backend

Customer -> TicketsApp: List events
TicketsApp -> Backend: View events
loop for each event
  TicketsApp -> Customer: Show event
end
#+end_src

#+RESULTS:
[[file:./img/list-events.png]]

*** Buy ticket

**** V1
#+begin_src plantuml :file ./img/v1-buy-ticket.png
title Buy ticket

actor Customer
participant TicketsApp
participant EventManager
participant ERC20Contract
participant EventTicket

Customer -> TicketsApp: Attend to event
TicketsApp -> EventManager: Buy ticket
activate EventManager
EventManager -> ERC20Contract: Transfer tokens from customer
EventManager -> EventTicket: Mint ticket
EventTicket -->> TicketsApp: Emits EventTicketVerified
deactivate EventManager
TicketsApp -> Customer: Congratulation, here is your ticket
#+end_src

#+RESULTS:
[[file:./img/v1-buy-ticket.png]]

*** Add / remove staff

#+begin_src plantuml :file ./img/assign-event-staff.png
title Add / remove staff

actor Master
participant TicketsApp
participant EventManager

Master -> TicketsApp: Make EOA staff
TicketsApp -> EventManager: Grant / revoke staff role
#+end_src

#+RESULTS:
[[file:./img/assign-event-staff.png]]

*** Show ticket

#+begin_src plantuml :file ./img/show-ticket.png
actor Customer
participant TicketsApp
participant SmartContract
participant CyberValleyEventTicket

Customer -> TicketsApp: Show ticket for the given event
TicketsApp -> CyberValleyEventTicket: ticketMeta(tokenId)
TicketsApp -> Customer: Show ticket QR
#+end_src

#+RESULTS:
[[file:./img/show-ticket.png]]

*** Verify bought ticket

#+begin_src plantuml :file ./img/verify-bought-ticket.png
title Verify bought ticket

actor Customer
actor Staff
participant TicketsApp
participant EventTicket

Customer -> TicketsApp: Display QR
Customer -> Staff: Show QR
Staff -> TicketsApp: Verify QR
TicketsApp -> EventTicket: Redeem ticket
#+end_src

#+RESULTS:
[[file:./img/verify-bought-ticket.png]]

*** Close event

#+begin_src plantuml :file ./img/close-event.png
actor Master
participant TicketsApp
participant EventManager
actor ERC20Contract
participant Backend

Master -> TicketsApp: Close event
TicketsApp -> EventManager: Close event
activate EventManager
  EventManager -> ERC20Contract: Spread shares between master, creator and devTeam
  EventManager --> Backend: Emit EventStatusChanged
deactivate EventManager
#+end_src

#+RESULTS:
[[file:./img/close-event.png]]

** Tech stack

Solidity, OpenZeppelin (=@openzeppelin/contracts@4.9.3=), React, TypeScript, Tailwind, ethers.js, IPFS

Also a thin backend over database is required to provide free of charge ability to change event request data before it's approve, so it'll be implemented with Python, Valkey and Litestar

** Excluded features from the first stage

Given list of features can be interpreted as obviously required or any section below can unintentionally imply them, so they explicitly mentioned

- Tickets refund
- Cancel or refund event request submission
- Any sort of push notifications about any updates or new data
- Ticket price change on sold out and increasing available seats
- Remove assigned staff person to the event

** Proxy contract vs multiple versions

Because of big amount of reads from the blockchain (which lead to spending gas on call delegation in proxy) we offer to use multiple versions and support them on the client side. To prevent difficulties of funds & data migration between versions, we'll create new events in a new version, but still support the previous ones until all events there will be closed or canceled.

** Component design

*** General overview

#+begin_src plantuml :file ./img/component-design.png
title General component design

() Customer

component TicketsApp {
}

component SmartContracts {
  [CyberValleyEventManager.sol]
  [CyberValleyEventTicket.sol]
  [DateOverlapChecker.sol]
}

database Backend {
  database Database
}

cloud IPFS

[Customer] -- TicketsApp : Uses

TicketsApp -- SmartContracts : Interacts with
TicketsApp -- IPFS : Stores/Fetches Metadata
TicketsApp -- Backend : Interacts with
Backend -- Database : Stores unapproved event requests

[CyberValleyEventManager.sol] -- [CyberValleyEventTicket.sol] : Mints Tickets
[CyberValleyEventManager.sol] -- [DateOverlapChecker.sol] : Checks Date Overlaps
#+end_src

#+RESULTS:
[[file:./img/component-design.png]]

*** Smart contract

**** Event manager

#+begin_src plantuml :file ./img/event-manager.png
class CyberValleyEventManager {
  - events: Event[]
  - eventPlaces: EventPlace[]
  - usdtTokenContract: IERC20
  - eventTicketContract: CyberValleyEventTicket
  - devTeamPercentage: uint256
  - devTeam: address
  - masterPercentage: uint256
  - master: address
  - eventRequestPrice: uint256

  - {static} MASTER_ROLE: bytes32

  + createEventPlace(maxTickets: uint16, minTickets: uint16, minPrice: uint16, minDays: uint8)
  + updateEventPlace(eventPlaceId: uint256, maxTickets: uint16, minTickets: uint16, minPrice: uint16, minDays: uint8)
  + submitEventRequest(eventPlaceId: uint256, ticketPrice: uint16, cancelDate: uint256, startDate: uint256, daysAmount: uint16)
  + approveEvent(eventId: uint256)
  + declineEvent(eventId: uint256)
  + updateEvent(eventId: uint256, eventPlaceId: uint256, ticketPrice: uint16, cancelDate: uint256, startDate: uint256, daysAmount: uint16)
  + cancelEvent(eventId: uint256)
  + closeEvent(eventId: uint256)
  + mintTicket(eventId: uint256, digest: bytes32, hashFunction: uint8, size: uint8)
}

class Event {
  - creator: address
  - eventPlaceId: uint256
  - ticketPrice: uint16
  - cancelDate: uint256
  - startDate: uint256
  - daysAmount: uint16
  - status: EventStatus
  - customers: address[]
}

enum EventStatus {
  Submitted,
  Approved,
  Declined,
  Cancelled,
  Closed
}

class EventPlace {
  - maxTickets: uint16
  - minTickets: uint16
  - minPrice: uint16
  - minDays: uint8
}

interface IERC20 {
  + transferFrom(address sender, address recipient, uint256 amount)
  + transfer(address recipient, uint256 amount)
  + balanceOf(address account): uint256
  + allowance(address owner, address spender): uint256
}

class CyberValleyEventTicket {
  + mint(address to, uint256 eventId, bytes32 digest, uint8 hashFunction, uint8 size)
}

abstract class AccessControl {
  + grantRole(bytes32 role, address account)
  + revokeRole(bytes32 role, address account)
  + hasRole(bytes32 role, address account): bool
}

CyberValleyEventManager --|> AccessControl
CyberValleyEventManager --o IERC20
CyberValleyEventManager --o CyberValleyEventTicket
CyberValleyEventManager --> Event
CyberValleyEventManager --> EventPlace
Event --> EventStatus
#+end_src

#+RESULTS:
[[file:./img/event-manager.png]]

***** Create event place

*Accessible only by master*

Adds a new event place

*Emits* ~NewEventPlaceAvailable~

Validations:
-   =eventPlace.maxTickets >= eventPlace.minTickets=, "Max tickets must be greater or equal min tickets"
-   =eventPlace.maxTickets > 0 && eventPlace.minTickets > 0 && eventPlace.minPrice > 0 && eventPlace.minDays > 0=, "Values must be greater than zero"

***** Update event place

*Accessible only by master*

Updates existing event place by it's id

@@warning:Event place can't be changed if there is another event@@

*Emits* ~EventPlaceUpdated~

Validations:
-   =eventPlaceId < eventPlaces.length=, "eventPlaceId should exist"
-   =eventPlace.maxTickets >= eventPlace.minTickets=, "Max tickets must be greater or equal min tickets"
-   =eventPlace.maxTickets > 0 && eventPlace.minTickets > 0 && eventPlace.minPrice > 0 && eventPlace.minDays > 0=, "Values must be greater than zero"

***** Submit event request

*Public*

Creates new event request.

Validations:
-   =usdtTokenContract.balanceOf(msg.sender) >= eventRequestPrice=, "Not enough tokens"
-   =usdtTokenContract.allowance(msg.sender, address(this)) >= eventRequestPrice=, "Required amount was not allowed"

***** Approve event

*Accessible only by master*

Transforms event request into the proper event which is visible to others

*Emits* ~EventStatusChanged~

Validations:

-   =evt.status == EventStatus.Submitted=, "Event status differs from submitted"

***** Decline event

*Accessible only by master*

Removes event request from the queue and refunds means to the creator

*Emits* ~EventStatusChanged~

Validations:

-   =evt.status == EventStatus.Submitted=, "Event status differs from submitted"

***** Update event

*Accessible only by master*

Allows to change the event data.

*Emits* ~EventUpdated~

***** Cancel event

*Accessible only by master*

Cancels given event and refunds all means between creator and customers who bought a ticket

*Emits* ~EventStatusChanged~

Validations:

-   =evt.status == EventStatus.Approved=, "Only event in approved state can be cancelled"
-   =block.timestamp >= evt.cancelDate=, "Event can not be cancelled before setted date"

***** Close event

*Accessible only by master*

Closes given event and sends means to the master, creator and dev team according to their shares

*Emits* ~EventStatusChanged~

Validations:

-   =evt.status == EventStatus.Approved=, "Only event in approved state can be closed"
-   =block.timestamp >= evt.startDate + evt.daysAmount * SECONDS_IN_DAY=, "Event has not been finished yet"

***** Mint ticket

*Accessible by event manager*

Checks if provided NFT was minted by the =EventManager= contract and connected to the given event.

@@warning:Marks the ticket as used for the current day and makes it impossible to reenter the event@@

Validations:

-   =evt.customers.length < eventPlaces[evt.eventPlaceId].maxTickets=, "Sold out"

**** Event ticket

#+begin_src plantuml :file ./img/event-ticket.png
class CyberValleyEventTicket {
  - name: string
  - symbol: string
  - eventManagerAddress: address
  - ticketsMeta: mapping(uint256 => Multihash)
  - isRedeemed: mapping(uint256 => bool)

  - {static} MASTER_ROLE: bytes32
  - {static} STAFF_ROLE: bytes32
  - {static} EVENT_MANAGER_ROLE: bytes32

  + setEventManagerAddress(_eventManagerAddress: address)
  + mint(address to: address, eventId: uint256, digest: bytes32, hashFunction: uint8, size: uint8)
  + ticketMeta(tokenId: uint256): (bytes32 digest, uint8 hashFunction, uint8 size)
  + redeemTicket(tokenId: uint256)
}

class Multihash {
  - digest: bytes32
  - hashFunction: uint8
  - size: uint8
}

interface IERC721 {
    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
}

interface IERC721Metadata {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

abstract class AccessControl {
  + grantRole(bytes32 role, address account)
  + revokeRole(bytes32 role, address account)
  + hasRole(bytes32 role, address account): bool
}

CyberValleyEventTicket --> Multihash
CyberValleyEventTicket --|> IERC721
CyberValleyEventTicket --|> IERC721Metadata
CyberValleyEventTicket --|> AccessControl
#+end_src

#+RESULTS:
[[file:./img/event-ticket.png]]

*** Backend

It's required for the two general purposes:

- Temporal storage for the event requests
- Indexing of smart contract state

Both of this solutions provide the most minimal off-chain reading pricing (probably even fit into free tier) and allow to publicly expose them without difficult caching system

**** Temporal event request storage
***** POST /events/requests

*Auth* public

Saves event request before the payment and storing in the blockchain. Customer who had sent event request becomes creator and can list his submissions.

Because this endpoint is publicly available for the V1 the request pool is introduced of big enough size (100_000 or even more). Requests from it will be translated to the persistent memory only after getting event from the =EventManager= about approved payment. This will make it harder to spam requests and make it harder to block the system in general.

*Returns* Saved event request id

#+begin_src plantuml :file ./img/event-request-model.png
class EventRequestModel {
  creator: string
  eventPlaceId: int
  ticketPrice: int
  startDate: datetime
  cancelDate: datetime
  daysAmount: int
}
#+end_src

#+RESULTS:
[[file:./img/event-request-model.png]]

***** GET /events/requests

*Auth* master or creator

*Returns* List of all pending =EventRequestModel= for the master and only owned for creator

***** POST /events

*Auth* master

Converts given event request by it's id into event and stores it in IPFS
Deletes event request from the storage

*Returns* =404= if event request wasn't found

#+begin_src plantuml :file ./img/new-event-model.png
class NewEventModel {
  eventId: int
}
#+end_src

#+RESULTS:
[[file:./img/new-event-model.png]]

**** Indexer
***** GET /events

Allows to effectively fetch all events (finished and pending)

*Returns* List of =EventModel=

#+begin_src plantuml :file ./img/event-model.png
class EventModel {
  + name: string
  + creator: CreatorModel
  + description: DescriptionModel
  + startsAt: datetime
  + daysAmount: int
  + place: EventPlaceModel
  + availableSeats: int
  + ticketPrice: int
}

class CreatorModel {
  + name: string
  + contact: SocialContactModel
}

class DescriptionModel {
  + text: string
  + links: string[]
  + pictureUrl: string
}

class EventPlaceModel {
  + name: string
  + totalSeats: int
}

class SocialContactModel {
  + value: Telegram | Discord | WhatsApp | Instagram
}

EventModel --> CreatorModel
EventModel --> DescriptionModel
EventModel --> EventPlaceModel
CreatorModel --> SocialContactModel
#+end_src

#+RESULTS:
[[file:./img/event-model.png]]

***** GET /event/{event-id}/ticket/{ticket-id}

*Auth* Master & staff

*Returns* Ticket metadata for the given event

#+begin_src plantuml :file ./img/event-ticket-model.png
class EventTicketModel {
  eventId: string
  owner: string
  socials: Socials
  days: int
  usage: int
}
#+end_src

#+RESULTS:
[[file:./img/event-ticket-model.png]]

**** Sign-in with Ethereum

Because of requirement to allow posting and fetching event requests for the master some authentication process should be made. It could be made with JWT and [[https://docs.metamask.io/wallet/how-to/sign-data/#use-personal_sign][Infura's ~personal_sign~ method]]

***** POST /auth/generate-nonce/{public-address}

Generates session and checks if the given ~public-address~ is allowed to sign-in

*Returns* nonce or =403=

***** POST /auth/verify-signature/{public-address}

Verifies signature and returns JWT

*Returns* JWT token or =403=

#+begin_src plantuml :file ./img/verify-signature-model.png
class VerifySignatureModel {
  signature: string
}
#+end_src

#+RESULTS:
[[file:./img/verify-signature-model.png]]

* Questions

** Both desktop and mobile are required?

#+begin_quote
Mobile only
#+end_quote

** Is it required to verify tickets without internet connection?

#+begin_quote
No
#+end_quote

** Will be there multiple masters or the only one in foreseeable future?

#+begin_quote
Only one
#+end_quote

** Event request price fixed in ETH, depends on ETH/USD rate or could be changed by the master?

#+begin_quote
Smart contract should work with USDT
#+end_quote

** Is a ticket transfer allowed e.g. customer A bought a ticket, but sent it to the customer B?

#+begin_quote
Yes
#+end_quote

It requires additional UI and flows to properly update ticket's meta data, so this feature will be skipped in the V1

** Will tickets have some metainfo about the owner (name, number etc)

#+begin_quote
Yes, socials i.e. one or many {Telegram, Discord, Instagram, Whats App}
#+end_quote

** Is it applicable to show available seats count for all (so the creator and master can see it as well without additional screen)?

#+begin_quote
Yes
#+end_quote

** UI design references

#+begin_quote
https://dribbble.com/shots/23082238-Earthquake-Warning-App-Cyberpunk-Design-Style
#+end_quote
